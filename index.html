<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Watchlist Recommender</title>
  <style>
    body { font-family: -apple-system, system-ui, Arial; margin: 18px; line-height: 1.35; }
    .card { border: 1px solid #ddd; border-radius: 16px; padding: 14px; max-width: 900px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: end; }
    input, select, button { font-size: 16px; padding: 10px 12px; border-radius: 12px; border: 1px solid #ccc; }
    button { border: 0; cursor: pointer; }
    button.primary { background: #111; color: #fff; }
    button.secondary { background: #eee; color: #111; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin: 10px 0 0; }
    .tab { padding: 8px 10px; border-radius: 999px; border: 1px solid #ccc; background:#fff; cursor:pointer; }
    .tab.active { background:#111; color:#fff; border-color:#111; }
    small { color: #555; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .status { margin-top: 10px; color: #333; }
    .result { margin-top: 14px; padding-top: 12px; border-top: 1px dashed #ddd; }
    a { color: #0b57d0; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .muted { color:#666; }
    .grid { display:grid; gap:10px; grid-template-columns: 1fr; margin-top: 10px; }
    @media (min-width: 740px) { .grid { grid-template-columns: 1fr 1fr; } }
    .panel { border:1px solid #e5e5e5; border-radius:14px; padding:12px; }
    .danger { color:#b00020; }
    .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid #ddd; margin: 4px 6px 0 0; }
  </style>
</head>
<body>
  <div class="card">
    <h2>üçø Watchlist Recommender</h2>
    <p class="muted">
      Upload your <span class="mono">watchlist.csv</span> from a Letterboxd export once (it‚Äôs saved in your browser),
      then use TMDb for genres + similar-movie recommendations.
    </p>

    <div class="row">
      <label>
        TMDb API Key (v3)<br/>
        <input id="apiKey" placeholder="paste key here" />
      </label>

      <label>
        Upload watchlist.csv<br/>
        <input type="file" id="csvFile" accept=".csv" />
      </label>

      <button class="secondary" id="clearCache">Clear saved watchlist</button>
      <button class="primary" id="recommendBtn">Recommend</button>
    </div>

    <div class="tabs" id="tabs">
      <button class="tab active" data-tab="random">Random (watchlist)</button>
      <button class="tab" data-tab="genre">By genre (watchlist)</button>
      <button class="tab" data-tab="similar_any">Similar to‚Ä¶ (any)</button>
      <button class="tab" data-tab="similar_watchlist">Similar to‚Ä¶ (on watchlist)</button>
    </div>

    <div class="grid">
      <div class="panel" id="panel_random">
        <b>Random from watchlist</b>
        <p class="muted">Picks a random film from your uploaded watchlist.</p>
      </div>

      <div class="panel" id="panel_genre" style="display:none;">
        <b>Pick by genre (from your watchlist)</b>
        <p class="muted">Uses TMDb genres. After you upload your watchlist, this samples your list to find a match.</p>
        <label>
          Genre<br/>
          <select id="genreSelect"></select>
        </label>
      </div>

      <div class="panel" id="panel_similar_any" style="display:none;">
        <b>Similar to a movie you liked (any movie)</b>
        <p class="muted">Searches TMDb for your seed movie, then picks a random ‚Äúsimilar‚Äù title.</p>
        <label>
          Movie title<br/>
          <input id="seedTitle" placeholder="e.g., Interstellar" />
        </label>
        <div class="row" style="margin-top:8px;">
          <label>
            Year (optional)<br/>
            <input id="seedYear" inputmode="numeric" placeholder="2014" style="width:140px;" />
          </label>
          <label>
            Sample size<br/>
            <select id="similarPool">
              <option value="10">10</option>
              <option value="20" selected>20</option>
              <option value="40">40</option>
            </select>
          </label>
        </div>
      </div>

      <div class="panel" id="panel_similar_watchlist" style="display:none;">
        <b>Similar‚Ä¶ but MUST be on your watchlist</b>
        <p class="muted">Finds similar movies, then filters to titles that match your watchlist.</p>
        <label>
          Movie title<br/>
          <input id="seedTitle2" placeholder="e.g., Dune: Part Two" />
        </label>
        <div class="row" style="margin-top:8px;">
          <label>
            Year (optional)<br/>
            <input id="seedYear2" inputmode="numeric" placeholder="2024" style="width:140px;" />
          </label>
          <label>
            Similar pool to scan<br/>
            <select id="similarPool2">
              <option value="20">20</option>
              <option value="40" selected>40</option>
              <option value="60">60</option>
            </select>
          </label>
        </div>
      </div>
    </div>

    <div class="status" id="status"></div>
    <div class="result" id="result" style="display:none;"></div>

    <p style="margin-top:12px;">
      <small class="muted">
        Tip: After you upload <span class="mono">watchlist.csv</span> once, it‚Äôs saved locally. Re-upload only when your watchlist changes.
      </small>
    </p>
  </div>

<script>
/***********************
 * 0) OPTIONAL HARDCODE
 ***********************/
// Don't hardcode your TMDb key if you're going to host this publicly.
// Leave blank and paste it into the UI; it will be saved in localStorage.
const HARDCODED_TMDB_KEY = "";

/***********************
 * 1) STATE + UI
 ***********************/
const elApiKey = document.getElementById("apiKey");
const elCsvFile = document.getElementById("csvFile");
const elClearCache = document.getElementById("clearCache");
const elRecommendBtn = document.getElementById("recommendBtn");
const elStatus = document.getElementById("status");
const elResult = document.getElementById("result");

const elGenreSelect = document.getElementById("genreSelect");
const elSeedTitle = document.getElementById("seedTitle");
const elSeedYear = document.getElementById("seedYear");
const elSimilarPool = document.getElementById("similarPool");
const elSeedTitle2 = document.getElementById("seedTitle2");
const elSeedYear2 = document.getElementById("seedYear2");
const elSimilarPool2 = document.getElementById("similarPool2");

const panels = {
  random: document.getElementById("panel_random"),
  genre: document.getElementById("panel_genre"),
  similar_any: document.getElementById("panel_similar_any"),
  similar_watchlist: document.getElementById("panel_similar_watchlist"),
};
let activeTab = "random";

// watchlist: { titleGuess, yearGuess, lbUrl }
let watchlist = [];
// genreMap: { idToName: {id: name}, nameToId: {nameLower: id} }
let genreMap = { idToName: {}, nameToId: {} };

// localStorage keys
const WATCHLIST_CACHE_KEY = "lb_watchlist_csv_cache_v3";
const TMDB_KEY_CACHE_KEY   = "tmdb_key_cache_v2";
const GENRE_CACHE_KEY      = "tmdb_genres_cache_v2";

/***********************
 * 2) UTIL
 ***********************/
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}

function setStatus(msg, isError=false) {
  elStatus.innerHTML = isError
    ? `<span class="danger">${escapeHtml(msg)}</span>`
    : escapeHtml(msg);
}

function showResult(html) {
  elResult.style.display = "block";
  elResult.innerHTML = html;
}

function hideResult() {
  elResult.style.display = "none";
  elResult.innerHTML = "";
}

function pickRandom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

function ensureWatchlistLoaded() {
  if (!Array.isArray(watchlist) || watchlist.length === 0) {
    throw new Error("Upload watchlist.csv first.");
  }
}

function normalizeTitle(s) {
  return String(s || "")
    .toLowerCase()
    .replace(/[‚Äô']/g, "")
    .replace(/&/g, " and ")
    .replace(/[^a-z0-9 ]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

/***********************
 * 3) TABS
 ***********************/
document.getElementById("tabs").addEventListener("click", (e) => {
  const btn = e.target.closest("button[data-tab]");
  if (!btn) return;

  activeTab = btn.dataset.tab;

  document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
  btn.classList.add("active");

  Object.entries(panels).forEach(([k, el]) => {
    el.style.display = (k === activeTab) ? "block" : "none";
  });

  hideResult();
});

/***********************
 * 4) CSV PARSING (Letterboxd watchlist.csv)
 ***********************/
function parseCSV(text) {
  // Handles commas inside quotes + escaped quotes ("")
  const rows = [];
  let row = [];
  let cur = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    const next = text[i + 1];

    if (c === '"' && next === '"') { cur += '"'; i++; continue; }
    if (c === '"') { inQuotes = !inQuotes; continue; }

    if (!inQuotes && c === ",") {
      row.push(cur);
      cur = "";
      continue;
    }

    if (!inQuotes && (c === "\n" || c === "\r")) {
      if (c === "\r" && next === "\n") i++; // CRLF
      row.push(cur);
      cur = "";
      if (row.some(cell => String(cell).trim() !== "")) rows.push(row);
      row = [];
      continue;
    }

    cur += c;
  }

  if (cur.length || row.length) {
    row.push(cur);
    if (row.some(cell => String(cell).trim() !== "")) rows.push(row);
  }

  return rows;
}

function watchlistFromCSV(csvText) {
  const rows = parseCSV(csvText);
  if (rows.length < 2) throw new Error("CSV looks empty.");

  const headers = rows[0].map(h => String(h).trim().toLowerCase());

  // Letterboxd export headers usually include: Name, Year, Letterboxd URI
  const idxName = headers.indexOf("name");
  const idxYear = headers.indexOf("year");
  const idxUri  = headers.findIndex(h => h.includes("letterboxd uri"));

  if (idxName === -1) {
    throw new Error("Couldn‚Äôt find a 'Name' column. Make sure this is Letterboxd watchlist.csv (from export ZIP).");
  }

  const items = [];
  for (let i = 1; i < rows.length; i++) {
    const r = rows[i] || [];
    const name = String(r[idxName] || "").trim();
    if (!name) continue;

    const year = idxYear !== -1 ? String(r[idxYear] || "").trim() : "";
    const lbUrl = idxUri !== -1 ? String(r[idxUri] || "").trim() : "";

    items.push({
      titleGuess: name,
      yearGuess: year,
      lbUrl: lbUrl || null
    });
  }

  if (!items.length) throw new Error("No movies parsed from CSV.");
  return items;
}

elCsvFile.addEventListener("change", async () => {
  try {
    const file = elCsvFile.files?.[0];
    if (!file) return;

    setStatus("Reading CSV‚Ä¶");
    const text = await file.text();
    watchlist = watchlistFromCSV(text);

    localStorage.setItem(WATCHLIST_CACHE_KEY, JSON.stringify({
      savedAt: Date.now(),
      items: watchlist
    }));

    setStatus(`Loaded ${watchlist.length} films from watchlist.csv.`);
    hideResult();
  } catch (e) {
    setStatus(`Error: ${e.message}`, true);
  }
});

elClearCache.addEventListener("click", () => {
  localStorage.removeItem(WATCHLIST_CACHE_KEY);
  watchlist = [];
  hideResult();
  setStatus("Cleared saved watchlist. Upload watchlist.csv again.");
});

/***********************
 * 5) TMDb API
 ***********************/
function getTmdbKey() {
  const typed = elApiKey.value.trim();
  if (typed) return typed;

  const cached = (localStorage.getItem(TMDB_KEY_CACHE_KEY) || "").trim();
  if (cached) return cached;

  if (HARDCODED_TMDB_KEY) return HARDCODED_TMDB_KEY.trim();

  return "";
}

function requireTmdbKey() {
  const k = getTmdbKey();
  if (!k) throw new Error("TMDb key missing. Paste your v3 API key at the top.");
  return k;
}

async function tmdbGet(path, params = {}) {
  const key = requireTmdbKey();
  const url = new URL(`https://api.themoviedb.org/3/${path}`);
  url.searchParams.set("api_key", key);
  for (const [k, v] of Object.entries(params)) {
    if (v !== undefined && v !== null && String(v).trim() !== "") {
      url.searchParams.set(k, v);
    }
  }

  const res = await fetch(url.toString());
  if (!res.ok) {
    let txt = "";
    try { txt = await res.text(); } catch {}
    throw new Error(`TMDb error ${res.status}${txt ? `: ${txt.slice(0, 140)}` : ""}`);
  }
  return await res.json();
}

async function loadGenreMap() {
  // Try cache first
  const raw = localStorage.getItem(GENRE_CACHE_KEY);
  if (raw) {
    try {
      const parsed = JSON.parse(raw);
      if (parsed?.idToName && parsed?.nameToId) {
        genreMap = parsed;
        populateGenreSelect();
        return;
      }
    } catch {}
  }

  setStatus("Loading TMDb genres‚Ä¶");
  const data = await tmdbGet("genre/movie/list", { language: "en-US" });

  const idToName = {};
  const nameToId = {};
  (data.genres || []).forEach(g => {
    idToName[g.id] = g.name;
    nameToId[String(g.name).toLowerCase()] = g.id;
  });

  genreMap = { idToName, nameToId };
  localStorage.setItem(GENRE_CACHE_KEY, JSON.stringify(genreMap));
  populateGenreSelect();
}

function populateGenreSelect() {
  const previousValue = elGenreSelect.value;

  elGenreSelect.innerHTML = "";

  const names = Object.values(genreMap.idToName).sort((a, b) => a.localeCompare(b));
  for (const name of names) {
    const opt = document.createElement("option");
    opt.value = String(genreMap.nameToId[String(name).toLowerCase()]);
    opt.textContent = name;
    elGenreSelect.appendChild(opt);
  }

  if (previousValue) elGenreSelect.value = previousValue;
}

async function tmdbSearchMovie(title, yearOptional) {
  const data = await tmdbGet("search/movie", {
    query: title,
    year: yearOptional || undefined,
    include_adult: "false",
    language: "en-US"
  });

  const best = (data.results || [])[0];
  if (!best) throw new Error(`No TMDb results for "${title}". Try adding the year.`);
  return best;
}

async function tmdbMovieDetails(movieId) {
  // Gives richer fields than search: genres[], imdb_id, etc.
  return await tmdbGet(`movie/${movieId}`, { language: "en-US" });
}

async function tmdbSimilar(movieId, maxCount) {
  // Pull multiple pages if needed
  const want = Number(maxCount);
  const out = [];
  let page = 1;

  while (out.length < want) {
    const data = await tmdbGet(`movie/${movieId}/similar`, { language: "en-US", page });
    const results = data.results || [];
    if (!results.length) break;

    out.push(...results);
    if (page >= (data.total_pages || 1)) break;
    page++;
    // gentle pacing
    await sleep(80);
  }

  return out.slice(0, want);
}

function tmdbPosterUrl(path) {
  if (!path) return null;
  return `https://image.tmdb.org/t/p/w500${path}`;
}

/***********************
 * 6) RENDER
 ***********************/
function renderPick(tm, opts = {}) {
  const poster = tmdbPosterUrl(tm.poster_path);
  const year = (tm.release_date || "").slice(0, 4);

  // tm may come from search/similar; use genre_ids when present, else map tm.genres
  let genres = [];
  if (Array.isArray(tm.genre_ids) && tm.genre_ids.length) {
    genres = tm.genre_ids.map(id => genreMap.idToName[id]).filter(Boolean);
  } else if (Array.isArray(tm.genres) && tm.genres.length) {
    genres = tm.genres.map(g => g?.name).filter(Boolean);
  }

  const lbLink = opts.lbUrl
    ? `<p><a href="${opts.lbUrl}" target="_blank" rel="noopener">Open on Letterboxd</a></p>`
    : "";

  const tmdbLink = tm.id ? `https://www.themoviedb.org/movie/${tm.id}` : null;

  const seedLine = opts.seed
    ? `<p class="muted"><small>Similar to: <span class="mono">${escapeHtml(opts.seed.title)} (${escapeHtml((opts.seed.release_date || "").slice(0, 4))})</span></small></p>`
    : "";

  showResult(`
    ${seedLine}
    <div style="display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap;">
      ${poster ? `<img src="${poster}" alt="" style="width:120px; border-radius:12px; border:1px solid #eee;">` : ""}
      <div style="min-width:240px; flex:1;">
        <h3 style="margin:0 0 6px;">${escapeHtml(tm.title || "Untitled")}${year ? ` <span class="muted">(${escapeHtml(year)})</span>` : ""}</h3>
        ${genres.length ? `<div>${genres.map(g => `<span class="pill">${escapeHtml(g)}</span>`).join("")}</div>` : ""}
        ${tm.overview ? `<p style="margin:10px 0 0;">${escapeHtml(tm.overview)}</p>` : ""}
        ${tmdbLink ? `<p style="margin:10px 0 0;"><a href="${tmdbLink}" target="_blank" rel="noopener">Open on TMDb</a></p>` : ""}
        ${lbLink}
      </div>
    </div>
  `);
}

/***********************
 * 7) RECOMMENDERS
 ***********************/
async function recommendRandomFromWatchlist() {
  ensureWatchlistLoaded();

  setStatus("Picking random watchlist movie‚Ä¶");
  const pick = pickRandom(watchlist);

  setStatus(`Looking up "${pick.titleGuess}" on TMDb‚Ä¶`);
  const tm = await tmdbSearchMovie(pick.titleGuess, pick.yearGuess);

  // optional: get details for better genre list
  let details = null;
  try { details = await tmdbMovieDetails(tm.id); } catch {}
  renderPick(details || tm, { lbUrl: pick.lbUrl });

  setStatus("Done.");
}

async function recommendWatchlistByGenre(genreIdStr) {
  ensureWatchlistLoaded();
  const genreId = Number(genreIdStr);
  const gName = genreMap.idToName[genreId] || "that genre";

  // sample rather than scan entire watchlist
  const shuffled = watchlist.slice().sort(() => Math.random() - 0.5);
  const MAX_CHECKS = Math.min(50, shuffled.length);

  setStatus(`Searching your watchlist for ${gName}‚Ä¶`);

  for (let i = 0; i < MAX_CHECKS; i++) {
    const item = shuffled[i];
    setStatus(`Checking ${i + 1}/${MAX_CHECKS}: ${item.titleGuess}`);

    try {
      const tm = await tmdbSearchMovie(item.titleGuess, item.yearGuess);
      if ((tm.genre_ids || []).includes(genreId)) {
        let details = null;
        try { details = await tmdbMovieDetails(tm.id); } catch {}
        renderPick(details || tm, { lbUrl: item.lbUrl });
        setStatus(`Done. (${gName})`);
        return;
      }
    } catch {
      // ignore mismatches/failed searches
    }

    await sleep(120);
  }

  throw new Error(`Couldn‚Äôt find a ${gName} match in this sample. Click Recommend again to try a different sample.`);
}

async function recommendSimilarAny(seedTitle, seedYear, poolSize) {
  setStatus("Searching seed movie on TMDb‚Ä¶");
  const seed = await tmdbSearchMovie(seedTitle, seedYear);

  setStatus(`Getting similar movies to "${seed.title}"‚Ä¶`);
  const similars = await tmdbSimilar(seed.id, Number(poolSize));
  if (!similars.length) throw new Error("TMDb returned no similar movies for that title.");

  const pick = pickRandom(similars);
  renderPick(pick, { seed });
  setStatus("Done.");
}

async function recommendSimilarOnWatchlist(seedTitle, seedYear, poolSize) {
  ensureWatchlistLoaded();

  setStatus("Searching seed movie on TMDb‚Ä¶");
  const seed = await tmdbSearchMovie(seedTitle, seedYear);

  setStatus(`Getting similar movies to "${seed.title}"‚Ä¶`);
  const similars = await tmdbSimilar(seed.id, Number(poolSize));
  if (!similars.length) throw new Error("TMDb returned no similar movies for that title.");

  // build lookup from watchlist
  const wlMap = new Map();
  for (const w of watchlist) wlMap.set(normalizeTitle(w.titleGuess), w);

  const matches = [];
  for (const s of similars) {
    const key = normalizeTitle(s.title);
    const hit = wlMap.get(key);
    if (hit) matches.push({ tm: s, wl: hit });
  }

  if (!matches.length) {
    throw new Error("None of the similar titles matched your watchlist (in this pool). Try increasing the pool size or a different seed movie.");
  }

  const picked = pickRandom(matches);
  renderPick(picked.tm, { seed, lbUrl: picked.wl.lbUrl });
  setStatus("Done.");
}

/***********************
 * 8) MAIN BUTTON
 ***********************/
elRecommendBtn.addEventListener("click", async () => {
  try {
    hideResult();

    // save typed key
    const typed = elApiKey.value.trim();
    if (typed) localStorage.setItem(TMDB_KEY_CACHE_KEY, typed);

    // ensure key exists
    requireTmdbKey();

    // load genres (needed for pills)
    await loadGenreMap();

    if (activeTab === "random") {
      await recommendRandomFromWatchlist();
    } else if (activeTab === "genre") {
      await recommendWatchlistByGenre(elGenreSelect.value);
    } else if (activeTab === "similar_any") {
      const t = elSeedTitle.value.trim();
      if (!t) throw new Error("Enter a movie title you liked.");
      await recommendSimilarAny(t, elSeedYear.value.trim(), elSimilarPool.value);
    } else if (activeTab === "similar_watchlist") {
      const t = elSeedTitle2.value.trim();
      if (!t) throw new Error("Enter a movie title you liked.");
      await recommendSimilarOnWatchlist(t, elSeedYear2.value.trim(), elSimilarPool2.value);
    }
  } catch (e) {
    setStatus(`Error: ${e.message}`, true);
  }
});

/***********************
 * 9) INIT: restore cache
 ***********************/
(function init() {
  try {
    const cachedKey = localStorage.getItem(TMDB_KEY_CACHE_KEY);
    if (cachedKey && !elApiKey.value) elApiKey.value = cachedKey;

    const raw = localStorage.getItem(WATCHLIST_CACHE_KEY);
    if (raw) {
      const data = JSON.parse(raw);
      if (Array.isArray(data?.items) && data.items.length) {
        watchlist = data.items;
        setStatus(`Loaded ${watchlist.length} films from saved watchlist cache. Paste TMDb key (if needed) and hit Recommend.`);
        return;
      }
    }

    setStatus("Upload watchlist.csv, paste your TMDb key, then hit Recommend.");
  } catch {
    setStatus("Upload watchlist.csv, paste your TMDb key, then hit Recommend.");
  }
})();
</script>
</body>
</html>
