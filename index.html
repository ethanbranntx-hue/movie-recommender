<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Watchlist Recommender</title>
  <style>
    body { font-family: -apple-system, system-ui, Arial; margin: 18px; line-height: 1.35; color: #111; }
    .card { border: 1px solid #ddd; border-radius: 16px; padding: 20px; max-width: 900px; margin: auto; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: end; margin-bottom: 15px; }
    input, select, button { font-size: 16px; padding: 10px 12px; border-radius: 12px; border: 1px solid #ccc; }
    button { border: 0; cursor: pointer; transition: opacity 0.2s; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button.primary { background: #111; color: #fff; }
    button.secondary { background: #eee; color: #111; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin: 20px 0 10px; }
    .tab { padding: 8px 14px; border-radius: 999px; border: 1px solid #ccc; background:#fff; cursor:pointer; }
    .tab.active { background:#111; color:#fff; border-color:#111; }
    small { color: #555; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 0.9em; background: #f4f4f4; padding: 2px 4px; border-radius: 4px; }
    .status { margin-top: 15px; min-height: 1.5em; font-size: 14px; }
    .result { margin-top: 14px; padding-top: 20px; border-top: 1px dashed #ddd; }
    a { color: #0b57d0; text-decoration: none; font-weight: 500; }
    a:hover { text-decoration: underline; }
    .muted { color:#666; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr; margin-top: 10px; }
    @media (min-width: 740px) { .grid { grid-template-columns: 1fr 1fr; } }
    .panel { border:1px solid #e5e5e5; border-radius:14px; padding:15px; background: #fafafa; }
    .danger { color:#b00020; font-weight: bold; }
    .pill { display:inline-block; padding: 4px 12px; border-radius: 999px; border: 1px solid #ddd; margin: 4px 6px 0 0; font-size: 12px; background: #fff; }
  </style>
</head>
<body>

  <div class="card">
    <h2>üçø Watchlist Recommender</h2>
    <p class="muted">
      Upload your <span class="mono">watchlist.csv</span> from a Letterboxd export. It saves locally to your browser.
    </p>

    <div class="row">
      <label>
        TMDb API Key (v3)<br/>
        <input id="apiKey" type="password" placeholder="paste key here" />
      </label>

      <label>
        Upload watchlist.csv<br/>
        <input type="file" id="csvFile" accept=".csv" />
      </label>

      <button class="secondary" id="clearCache">Clear Cache</button>
      <button class="primary" id="recommendBtn">Recommend</button>
    </div>

    <div class="tabs" id="tabs">
      <button class="tab active" data-tab="random">Random</button>
      <button class="tab" data-tab="genre">By Genre</button>
      <button class="tab" data-tab="similar_any">Similar (Any)</button>
      <button class="tab" data-tab="similar_watchlist">Similar (Watchlist)</button>
    </div>

    <div class="grid">
      <div class="panel" id="panel_random">
        <b>Random Pick</b>
        <p class="muted">Picks a completely random film from your watchlist.</p>
      </div>

      <div class="panel" id="panel_genre" style="display:none;">
        <b>Filter by Genre</b>
        <p class="muted">Samples your list to find a specific genre match.</p>
        <label>Genre<br/><select id="genreSelect" style="width:100%"></select></label>
      </div>

      <div class="panel" id="panel_similar_any" style="display:none;">
        <b>Similar to... (Global)</b>
        <p class="muted">Finds a movie similar to your "seed" from all of TMDb.</p>
        <input id="seedTitle" placeholder="Movie title (e.g. Inception)" style="width:100%; margin-bottom:8px;"/>
        <input id="seedYear" placeholder="Year (optional)" style="width:100%"/>
      </div>

      <div class="panel" id="panel_similar_watchlist" style="display:none;">
        <b>Similar to... (Watchlist)</b>
        <p class="muted">Finds a movie similar to your "seed" that is <b>already</b> on your watchlist.</p>
        <input id="seedTitle2" placeholder="Movie title" style="width:100%; margin-bottom:8px;"/>
        <input id="seedYear2" placeholder="Year (optional)" style="width:100%"/>
      </div>
    </div>

    <div class="status" id="status"></div>
    <div class="result" id="result" style="display:none;"></div>
  </div>

<script>
/***********************
 * STATE & CONSTANTS
 ***********************/
const WATCHLIST_CACHE_KEY = "lb_watchlist_csv_cache_v3";
const TMDB_KEY_CACHE_KEY = "tmdb_key_cache_v2";
const GENRE_CACHE_KEY = "tmdb_genres_cache_v2";

let watchlist = [];
let genreMap = { idToName: {}, nameToId: {} };
let activeTab = "random";

const elApiKey = document.getElementById("apiKey");
const elCsvFile = document.getElementById("csvFile");
const elClearCache = document.getElementById("clearCache");
const elRecommendBtn = document.getElementById("recommendBtn");
const elStatus = document.getElementById("status");
const elResult = document.getElementById("result");
const elGenreSelect = document.getElementById("genreSelect");

const panels = {
  random: document.getElementById("panel_random"),
  genre: document.getElementById("panel_genre"),
  similar_any: document.getElementById("panel_similar_any"),
  similar_watchlist: document.getElementById("panel_similar_watchlist"),
};

/***********************
 * UTILS
 ***********************/
const escapeHtml = (s) => String(s).replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
const setStatus = (msg, isError=false) => elStatus.innerHTML = isError ? `<span class="danger">${msg}</span>` : msg;
const showResult = (html) => { elResult.style.display = "block"; elResult.innerHTML = html; };
const hideResult = () => { elResult.style.display = "none"; elResult.innerHTML = ""; };
const pickRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

function normalizeTitle(s) {
  return String(s || "").toLowerCase()
    .replace(/[‚Äô']/g, "")
    .replace(/&/g, " and ")
    .replace(/[^a-z0-9 ]/g, " ")
    .replace(/\s+/g, " ").trim();
}

/***********************
 * TMDB API CORE
 ***********************/
async function tmdbGet(path, params = {}) {
  const key = elApiKey.value.trim() || localStorage.getItem(TMDB_KEY_CACHE_KEY);
  if (!key) throw new Error("Please enter a TMDb API Key.");
  
  const url = new URL(`https://api.themoviedb.org/3/${path}`);
  url.searchParams.set("api_key", key);
  Object.entries(params).forEach(([k, v]) => { if(v) url.searchParams.set(k, v); });

  const res = await fetch(url);
  if (!res.ok) throw new Error(`TMDb API Error: ${res.status}`);
  return res.json();
}

async function loadGenreMap() {
  try {
    const data = await tmdbGet("genre/movie/list");
    genreMap.idToName = {};
    data.genres.forEach(g => {
      genreMap.idToName[g.id] = g.name;
      genreMap.nameToId[g.name.toLowerCase()] = g.id;
    });
    localStorage.setItem(GENRE_CACHE_KEY, JSON.stringify(genreMap));
    elGenreSelect.innerHTML = Object.values(genreMap.idToName).sort().map(name => 
      `<option value="${genreMap.nameToId[name.toLowerCase()]}">${name}</option>`).join("");
  } catch (e) { console.error("Genre load failed", e); }
}

/***********************
 * CSV & STORAGE
 ***********************/
function parseCSV(text) {
  const rows = []; let row = []; let cur = ""; let inQuotes = false;
  for (let i = 0; i < text.length; i++) {
    const c = text[i]; const next = text[i+1];
    if (c === '"' && next === '"') { cur += '"'; i++; continue; }
    if (c === '"') { inQuotes = !inQuotes; continue; }
    if (!inQuotes && c === ",") { row.push(cur); cur = ""; continue; }
    if (!inQuotes && (c === "\n" || c === "\r")) {
      if (c === "\r" && next === "\n") i++;
      row.push(cur); cur = "";
      if (row.some(cell => cell.trim() !== "")) rows.push(row);
      row = []; continue;
    }
    cur += c;
  }
  if (cur || row.length) { row.push(cur); if (row.some(c => c.trim() !== "")) rows.push(row); }
  return rows;
}

elCsvFile.addEventListener("change", async () => {
  try {
    const file = elCsvFile.files[0];
    const text = await file.text();
    const rows = parseCSV(text);
    const headers = rows[0].map(h => h.trim().toLowerCase());
    const idxName = headers.indexOf("name"), idxYear = headers.indexOf("year"), idxUri = headers.findIndex(h => h.includes("uri"));

    watchlist = rows.slice(1).map(r => ({
      titleGuess: r[idxName],
      yearGuess: idxYear !== -1 ? r[idxYear] : "",
      lbUrl: idxUri !== -1 ? r[idxUri] : null
    })).filter(x => x.titleGuess);

    localStorage.setItem(WATCHLIST_CACHE_KEY, JSON.stringify({ items: watchlist }));
    setStatus(`Success: ${watchlist.length} movies loaded.`);
  } catch (e) { setStatus("Error parsing CSV", true); }
});

elClearCache.addEventListener("click", () => {
  localStorage.clear();
  location.reload();
});

/***********************
 * LOGIC & RENDERING
 ***********************/
function renderPick(tm, opts = {}) {
  const poster = tm.poster_path ? `https://image.tmdb.org/t/p/w500${tm.poster_path}` : "";
  const genres = (tm.genre_ids || []).map(id => genreMap.idToName[id]).filter(Boolean);
  
  showResult(`
    ${opts.seed ? `<p class="muted"><small>Because you liked: <b>${escapeHtml(opts.seed.title)}</b></small></p>` : ""}
    <div style="display:flex; gap:15px; flex-wrap:wrap;">
      ${poster ? `<img src="${poster}" style="width:140px; border-radius:12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);">` : ""}
      <div style="flex:1; min-width:260px;">
        <h3 style="margin:0;">${escapeHtml(tm.title)} <span class="muted">(${(tm.release_date||"").slice(0,4)})</span></h3>
        <div style="margin:10px 0;">${genres.map(g => `<span class="pill">${escapeHtml(g)}</span>`).join("")}</div>
        <p style="font-size:14px; color:#444;">${escapeHtml(tm.overview || "No overview available.")}</p>
        <a href="https://www.themoviedb.org/movie/${tm.id}" target="_blank">View on TMDb</a>
        ${opts.lbUrl ? ` | <a href="${opts.lbUrl}" target="_blank">View on Letterboxd</a>` : ""}
      </div>
    </div>
  `);
}

elRecommendBtn.addEventListener("click", async () => {
  const btnText = elRecommendBtn.textContent;
  try {
    elRecommendBtn.disabled = true; elRecommendBtn.textContent = "Searching...";
    hideResult();
    
    if (elApiKey.value) localStorage.setItem(TMDB_KEY_CACHE_KEY, elApiKey.value.trim());
    if (!Object.keys(genreMap.idToName).length) await loadGenreMap();

    if (activeTab === "random") {
      if (!watchlist.length) throw new Error("Upload watchlist first.");
      const pick = pickRandom(watchlist);
      const s = await tmdbGet("search/movie", { query: pick.titleGuess, year: pick.yearGuess });
      renderPick(s.results[0], { lbUrl: pick.lbUrl });
    } 
    else if (activeTab === "genre") {
      const gid = Number(elGenreSelect.value);
      const shuffled = [...watchlist].sort(() => 0.5 - Math.random());
      for (let i = 0; i < Math.min(50, shuffled.length); i++) {
        setStatus(`Scanning: ${shuffled[i].titleGuess}...`);
        const s = await tmdbGet("search/movie", { query: shuffled[i].titleGuess, year: shuffled[i].yearGuess });
        if (s.results[0]?.genre_ids.includes(gid)) {
          renderPick(s.results[0], { lbUrl: shuffled[i].lbUrl });
          setStatus("Match found!"); return;
        }
        await sleep(150);
      }
      throw new Error("No match found in this sample.");
    }
    else if (activeTab.startsWith("similar")) {
      const isWatchlist = activeTab === "similar_watchlist";
      const titleInput = isWatchlist ? "seedTitle2" : "seedTitle";
      const title = document.getElementById(titleInput).value;
      if (!title) throw new Error("Enter a seed movie title.");

      const seedSearch = await tmdbGet("search/movie", { query: title });
      const seed = seedSearch.results[0];
      if (!seed) throw new Error("Seed movie not found.");
      
      const similarData = await tmdbGet(`movie/${seed.id}/similar`);
      const similars = similarData.results;

      if (isWatchlist) {
        const wlMap = new Map(watchlist.map(w => [normalizeTitle(w.titleGuess), w]));
        const matches = similars.filter(s => wlMap.has(normalizeTitle(s.title)));
        if (!matches.length) throw new Error("No similar movies found on your watchlist.");
        const pick = pickRandom(matches);
        renderPick(pick, { seed, lbUrl: wlMap.get(normalizeTitle(pick.title)).lbUrl });
      } else {
        renderPick(pickRandom(similars), { seed });
      }
    }
    setStatus("Done.");
  } catch (e) { setStatus(e.message, true); }
  finally { elRecommendBtn.disabled = false; elRecommendBtn.textContent = btnText; }
});

// Tab switching
document.getElementById("tabs").addEventListener("click", (e) => {
  const btn = e.target.closest("button[data-tab]");
  if (!btn) return;
  activeTab = btn.dataset.tab;
  document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
  btn.classList.add("active");
  Object.entries(panels).forEach(([k, el]) => el.style.display = (k === activeTab) ? "block" : "none");
});

// Initialization
(function init() {
  const cachedKey = localStorage.getItem(TMDB_KEY_CACHE_KEY);
  if (cachedKey) { elApiKey.value = cachedKey; loadGenreMap(); }
  const raw = localStorage.getItem(WATCHLIST_CACHE_KEY);
  if (raw) { watchlist = JSON.parse(raw).items; setStatus(`Ready: ${watchlist.length} movies cached.`); }
})();
</script>
</body>
</html>
